ts_plot <- plot(
x = energy_data,
type = "ts",
# variable =  c(`UNSP. ENRG`, `SPIL. ENRG`), # mais je le veux en négatif et je le veux en rouge
# variable =  c(-`UNSP. ENRG`, `SPIL. ENRG`),
# Error in X[[table]]$plotFun(mcYear, 1, variable, variable2Axe, elements,  :
#                               objet 'UNSP. ENRG' introuvable
#                             Called from: X[[table]]$plotFun(mcYear, 1, variable, variable2Axe, elements,
#                                                             type, typeConfInt, confInt, dateRange, minValue, maxValue,
#                                                             aggregate, legend, highlight, stepPlot, drawPoints, main)
## AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa
variable =  -`UNSP. ENRG`,
colors = "red",
elements = country,
dateRange = c(start_date, end_date),
#timeStep = timestep,
main = paste(timestep, "unsupplied energy for", country, "in 2015 (MWh)"),
interactive = FALSE
)
# fuck it, why not all timesteps ?
# mayb later i want to do graphes de défaillance là
# print(country)
# print(prod_data)
msg = paste("[OUTPUT] - Saving", timestep, "unsupplied/spilled energy for", country, "node...")
logFull(msg)
png_path = file.path(unsp_spil_dir, paste0(country, "_", timestep, ".png"))
#print(png_path)
savePlotAsPng(ts_plot, file = png_path,
width = WIDTH,
height = HEIGHT)
msg = paste("[OUTPUT] - The", timestep, "unsupplied/spilled energy for", country, "has been saved!")
logFull(msg)
}
}
}
# En fait, bientôt un readResults qui fait juste des appels à ces fonctions comme createStudy
# et donc, au même titre que j'ai un dossier "data" qui va ptet changer de nom, ranger les auxilliaires
# createStudyFunctions ? readResultsFunctions ?
nodes = oceania_nodes_lst
# si je commente en vrai, ça importe bien non ?
output_dir <- initializeOutputFolder(nodes) # ah ptn y a ça aussi aaaaaa
saveCountryProductionStacks(nodes,
output_dir,
#"productionStackColorblindSafe",
# Un peu mal foutu vu comment le titre du graphe change également si on change le stack
# En fait absolument tout peut changer mdr :
# le titre, l'unité, le timestep....
# il faudrait une fonction pour un stack en théorie
# "dynamic",
"productionStackWithBatteryContributions",
"daily") # la conclusion est formelle : faire des dossiers
# sinon avoir daily et hourly au mm endroit c insupportable
# NB SUR LES COULEURS DES STACKS : FAIRE UN MODE EASILY ACCESSIBLE POUR COLORBLIND
# saveUnsuppliedAndSpillage(nodes, output_dir, "hourly")
# Pour l'instant hélas ça bugge
# long term, this should probably end up in main/util
# and there should be like a h5 copy of study and simulation
# but so far, we want mostly screenshots soooooo
### let's make a function that saves a bunch of PNGs !
# savePlotAsPng(plot, file = "Rplot.png", width = 600, height = 480, ...)
#
# plot
# A plot generated with one of the functions of this package.
#
# ## Not run:
# mydata <- readAntares()
# myplot <- plot(mydata, variable = "MRG. PRICE", type = "density")
# savePlotAsPng(myplot, file = "myplot.png")
#
# # Lire les résultats de la simulation
# sim_results <- readAntares(
#   areas = "all",
#   links = "all",
#   clusters = "all",
#   mcYears = "all"
# )
#
# # Afficher les résultats
# print(sim_results)
# Todo : AntaresViz
################################################################################
# # Chargement des packages nécessaires
# library(antaresRead)
# library(antaresProcessing)
# library(antaresViz)
#
# # Définir le chemin vers le dossier de l'étude Antares
# # Dans l'idéal, faire ça dans la foulée dans que base_path et study_name sont encore en mémoire.
# # Ou alors, faire un truc qui les sauvegarde pour pouvoir les revisionner plus tard.
# chemin_etude <- file.path("antares", "examples", "studies", "Etude_sur_R_Monde__2024_07_26_19_22_38")
# # chemin_etude <- file.path("antares", "examples", "internal_studies", "9747b056-32ec-4a3f-a23e-e5c965594eec")
# simulation <- -1
#
# setSimulationPath(chemin_etude, simulation)
# print(simOptions())
# # Antares project 'Etude_sur_R_Monde__2024_07_26_19_22_38' (C:/Users/boissieremat/Documents/GitHub/antares-brinkerink-2015/antares/examples/studies/Etude_sur_R_Monde__2024_07_26_19_22_38)
# # Simulation 'NA'
# # Mode Economy
# #
# # Content:
# #   - synthesis: TRUE
# # - year by year: FALSE
# # - MC Scenarios: FALSE
# # - Number of areas: 42
# # - Number of districts: 0
# # - Number of links: 76
# # - Number of Monte-Carlo years: 0
# # si c'est vrai c'est très grave (year by year pas activé, alors qu'aurait du etre lu
# # au moment d'initialiser la simulation !!)
#
# #  Je me rappelle d'un autre truc aussi. Il a fallu cocher la case manuellemenet
# # pour générer des TS thermiques et dire à antares "j'en ai pas".
# # et... est-ce que ça s'automatise sur R, le déclenchement de ça ? parce que je galère à trouver.
# # ah, en fouillant le generaldata.ini, on dirait que c'est generate = thermal.
# # reste à le mettre dans updateSettings.
#
# # Définir la plage de dates
# start_date <- "2015-01-01"
# end_date <- "2015-12-31"
#
# # Charger les données de production au pas horaire pour toutes les zones
# mydata <- readAntares(areas = "all",
#                       # links = "all",
#                       # clusters = "all",
#                       mcYears = "all",
#                       # timeStep = c("hourly", "daily", "weekly", "monthly", "annual"), J'ARRIVE PAS A AVOIR REGLAGE
#                       select = c("SOLAR", "WIND", "GAS", "COAL", "NUCLEAR", "MIX. FUEL", "LOAD"),
#                       timeStep = "weekly"
# )
# #) # timeStep = "hourly",
#
# # Prochaine étape le graphe avec une carte imo
#
# #https://rdrr.io/github/rte-antares-rpackage/antaresViz/man/prodStack.html
#
# # Créer un alias pour la stack de production
# setProdStackAlias(
#   name = "customStack",
#   variables = alist(
#     NUCLEAR = NUCLEAR,
#     WIND = WIND,
#     SOLAR = SOLAR,
#     GAS = GAS,
#     COAL = COAL,
#     `MIX. FUEL` = `MIX. FUEL`
#   ),
#   colors = c("yellow", "turquoise", "orange", "red", "brown", "darkgreen"),
#   lines = alist(
#     LOAD = LOAD,
#     TOTAL_PRODUCTION =  NUCLEAR + WIND + SOLAR + GAS + COAL + `MIX. FUEL` # Curieux : j'ai un screen avec le bleu en bas
#   ),
#   lineColors = c("black", "royalblue")
# )
# # Ce serait bien d'avoir le load par-dessus pour visualiser défaillance,
# # ainsi qu'imports/exports. Mais pas sûr de comment faire.
#
# # Visualiser les données avec un empilement directement avec antaresViz
# prodStack(
#   x = mydata,
#   stack = "customStack",
#   areas = "all",
#   dateRange = c(start_date, end_date),
#   #timeStep = c("hourly", "daily", "weekly", "monthly", "annual"),
#   #timestep = "weekly",
#   #main = "Production horaire par mode de production",
#   unit = "MWh"
# )
## Script principal regroupant le coeur du processus ##
## Les objets sont typiquement déjà définis dans les fichiers auxilliaires
# Charger les packages
library(antaresRead)
library(antaresEditObject)
# Limite ça le EditObject pourrait être limité au CreateStudy
# Bon AntaresRead je vois pas comment faire sans mdr
# Penser à faire comme un requirements.txt genre le truc comme dans logging
# si pas packages alors les installer, et dire dans le README "au pire localement"
# Demander d'ailleurs si on peut virer "antares" du Gitignore
# pour démocratiser AntaresWeb (mais vu que c'est Nicolas qui me l'a filé...)
# Importer des fonctions et variables auxilliaires créées dans d'autres scripts
antaresFunctions_file = file.path("src", "antaresFunctions.R",
fsep = .Platform$file.sep)
source(antaresFunctions_file)
# Est-ce qu'on regroupe aussi les noms de modules dans les paramètres ?
# Est-ce qu'on sépare paramètres, faisant un dossier paramètres ? eh
addNodes_file = file.path("src", "data", "addNodes.R",
fsep = .Platform$file.sep)
source(addNodes_file)
logging_module = file.path("src", "logging.R",
fsep = .Platform$file.sep)
source(logging_module)
setRam(16)
# source("parameters.R")
if (EXPORT_TO_OUTPUT_FOLDER) {
output_dir <- paste0("./output/", generateName("run"))
if (!dir.exists(output_dir)) {
dir.create(output_dir)
}
}
# apparemment le format h5 sert à compresser tout ça ?
# # Convert your study in h5 format
# writeAntaresH5(path = mynewpath)
#
# # Redefine sim path with h5 file
# opts <- setSimulationPath(path = mynewpath)
# prodStack(x = opts)
################################################################################
################################# CREATE STUDY #################################
if (CREATE_STUDY) {
antaresCreateStudy_module = file.path("src", "antaresCreateStudy.R",
fsep = .Platform$file.sep)
source(antaresCreateStudy_module)
}
# Sah quel plaisir for it to run so smoothly now.
# Still gotta implement hydro, however.
# NEXT STEP FOR HYDRO :
# (pendant que j'envoie des sommes de capacité à nicolas chef oui chef)
# implémenter les objets Generator avec _Hyd_ en prenant les facteurs de charge mensuels
# en en faisant des TS horaires
# en faisant * max capacité * units
# et en mettant tout ça dans Run of River
# (not gonna lie, les autres propriétés, je sais pas ce qu'on en fait)
# MDRR C'EST PAS INDIVIDUEL PAR CONTRE c'est juste on va aggregate tous les RoR ensemble
# enfin j'ai l'impression
# à redemander avant à Nicolas
# génial
# et, les objets Battery de type PHS
# bah en vrai y a pas midi à 14h en terme de nombre de propriétés
# ce qui est pas clair dans ma tête à la rigueur c'est diff entre
# injection, soutirage, stock, efficacité
# (et surtout c'est pas redondant ? genre injection = stock * efficacité nn ?)
# AH NON SI OK J'AI je crois
# capacité c'est énorme c'est la maxi taille du réservoir genre 34800
# injection c'est oulah ça peut pas non plus fournir infini MW dans le réseau à un instant t
# et du coup c'est le max power qui ici est à 182
# il faut plutôt faire d'ailleurs un objet par units parce que y a pas de "unités"
# dans antares batteries
################################################################################
############################### LAUNCH SIMULATION ##############################
if (LAUNCH_SIMULATION) {
# Peut-être ici mettre les logs globaux ce qui permettrait de mettre genre
# starting simulation..
# ou skipped simulation... skipped reading results... done !
antaresLaunchSimulation_module = file.path("src", "antaresLaunchSimulation.R",
fsep = .Platform$file.sep)
source(antaresLaunchSimulation_module)
}
################################################################################
################################## READ RESULTS ################################
if (READ_RESULTS) {
antaresReadResults_module = file.path("src", "antaresReadResults.R",
fsep = .Platform$file.sep)
source(antaresReadResults_module)
}
################################################################################
# Commentaires variés
# Ca existe de stocker des objets R qqpart ?
# Ca peut diminuer le temps de fetch renewables.ninja, surtout quand on a peu de points.
# Mais, c'est peut-être plus risqué en un sens, je sais pas.
# Dans input un dossier "Robjects" ou quoi ça pourrait le faire.
# D'après stackoverflow :
#   You can use saveRDS and readRDS functions:
#
#     library(tibble)
#   test <- tibble(a= list(c(1,2), c(3,4)))
#   saveRDS(test, "c:/test.rds")
#   test_2 <- readRDS("c:/test.rds"))
# identical(test, test_2)
# In the readr package there are read_rds and write_rds functions, which even allow compression to be set.
# if (ADD_VOLL) {
#   addVoLL_module = file.path("src", "data", "addVoLL.R")
#   source(addVoLL_module)
#   addVoLLToAntares(nodes, study_path, study_name, log_verbose, console_verbose, fullLog_file, errorsLog_file)
#   message = paste(Sys.time(), "- [MAIN] Done adding VoLL !")
#   log_message(message, fullLog_file, console_verbose)
# }
# La suite : lancer une simulation et la visionner
# Sachant que le visionnage peut être un truc bien à faire dans un second temps
# Ce qu'il faut faire en fait c'est réussir à stocker genre des presets
# (dossiers studies tout prêts dans inputs ?)
# et prévoir de lancer des simulations, de visionner des résultats dans un second temps
# (des presets de simulation en fait aussi)
# (même pour tester des fonctions Viz de toute façon ce sera mieux)
## Script principal regroupant le coeur du processus ##
## Les objets sont typiquement déjà définis dans les fichiers auxilliaires
# Charger les packages
library(antaresRead)
library(antaresEditObject)
# Limite ça le EditObject pourrait être limité au CreateStudy
# Bon AntaresRead je vois pas comment faire sans mdr
# Penser à faire comme un requirements.txt genre le truc comme dans logging
# si pas packages alors les installer, et dire dans le README "au pire localement"
# Demander d'ailleurs si on peut virer "antares" du Gitignore
# pour démocratiser AntaresWeb (mais vu que c'est Nicolas qui me l'a filé...)
# Importer des fonctions et variables auxilliaires créées dans d'autres scripts
antaresFunctions_file = file.path("src", "antaresFunctions.R",
fsep = .Platform$file.sep)
source(antaresFunctions_file)
# Est-ce qu'on regroupe aussi les noms de modules dans les paramètres ?
# Est-ce qu'on sépare paramètres, faisant un dossier paramètres ? eh
addNodes_file = file.path("src", "data", "addNodes.R",
fsep = .Platform$file.sep)
source(addNodes_file)
logging_module = file.path("src", "logging.R",
fsep = .Platform$file.sep)
source(logging_module)
setRam(16)
# source("parameters.R")
if (EXPORT_TO_OUTPUT_FOLDER) {
output_dir <- paste0("./output/", generateName("run"))
if (!dir.exists(output_dir)) {
dir.create(output_dir)
}
}
# apparemment le format h5 sert à compresser tout ça ?
# # Convert your study in h5 format
# writeAntaresH5(path = mynewpath)
#
# # Redefine sim path with h5 file
# opts <- setSimulationPath(path = mynewpath)
# prodStack(x = opts)
################################################################################
################################# CREATE STUDY #################################
if (CREATE_STUDY) {
antaresCreateStudy_module = file.path("src", "antaresCreateStudy.R",
fsep = .Platform$file.sep)
source(antaresCreateStudy_module)
}
# Sah quel plaisir for it to run so smoothly now.
# Still gotta implement hydro, however.
# NEXT STEP FOR HYDRO :
# (pendant que j'envoie des sommes de capacité à nicolas chef oui chef)
# implémenter les objets Generator avec _Hyd_ en prenant les facteurs de charge mensuels
# en en faisant des TS horaires
# en faisant * max capacité * units
# et en mettant tout ça dans Run of River
# (not gonna lie, les autres propriétés, je sais pas ce qu'on en fait)
# MDRR C'EST PAS INDIVIDUEL PAR CONTRE c'est juste on va aggregate tous les RoR ensemble
# enfin j'ai l'impression
# à redemander avant à Nicolas
# génial
# et, les objets Battery de type PHS
# bah en vrai y a pas midi à 14h en terme de nombre de propriétés
# ce qui est pas clair dans ma tête à la rigueur c'est diff entre
# injection, soutirage, stock, efficacité
# (et surtout c'est pas redondant ? genre injection = stock * efficacité nn ?)
# AH NON SI OK J'AI je crois
# capacité c'est énorme c'est la maxi taille du réservoir genre 34800
# injection c'est oulah ça peut pas non plus fournir infini MW dans le réseau à un instant t
# et du coup c'est le max power qui ici est à 182
# il faut plutôt faire d'ailleurs un objet par units parce que y a pas de "unités"
# dans antares batteries
################################################################################
############################### LAUNCH SIMULATION ##############################
if (LAUNCH_SIMULATION) {
# Peut-être ici mettre les logs globaux ce qui permettrait de mettre genre
# starting simulation..
# ou skipped simulation... skipped reading results... done !
antaresLaunchSimulation_module = file.path("src", "antaresLaunchSimulation.R",
fsep = .Platform$file.sep)
source(antaresLaunchSimulation_module)
}
################################################################################
################################## READ RESULTS ################################
if (READ_RESULTS) {
antaresReadResults_module = file.path("src", "antaresReadResults.R",
fsep = .Platform$file.sep)
source(antaresReadResults_module)
}
################################################################################
# Commentaires variés
# Ca existe de stocker des objets R qqpart ?
# Ca peut diminuer le temps de fetch renewables.ninja, surtout quand on a peu de points.
# Mais, c'est peut-être plus risqué en un sens, je sais pas.
# Dans input un dossier "Robjects" ou quoi ça pourrait le faire.
# D'après stackoverflow :
#   You can use saveRDS and readRDS functions:
#
#     library(tibble)
#   test <- tibble(a= list(c(1,2), c(3,4)))
#   saveRDS(test, "c:/test.rds")
#   test_2 <- readRDS("c:/test.rds"))
# identical(test, test_2)
# In the readr package there are read_rds and write_rds functions, which even allow compression to be set.
# if (ADD_VOLL) {
#   addVoLL_module = file.path("src", "data", "addVoLL.R")
#   source(addVoLL_module)
#   addVoLLToAntares(nodes, study_path, study_name, log_verbose, console_verbose, fullLog_file, errorsLog_file)
#   message = paste(Sys.time(), "- [MAIN] Done adding VoLL !")
#   log_message(message, fullLog_file, console_verbose)
# }
# La suite : lancer une simulation et la visionner
# Sachant que le visionnage peut être un truc bien à faire dans un second temps
# Ce qu'il faut faire en fait c'est réussir à stocker genre des presets
# (dossiers studies tout prêts dans inputs ?)
# et prévoir de lancer des simulations, de visionner des résultats dans un second temps
# (des presets de simulation en fait aussi)
# (même pour tester des fonctions Viz de toute façon ce sera mieux)
## Script principal regroupant le coeur du processus ##
## Les objets sont typiquement déjà définis dans les fichiers auxilliaires
# Charger les packages
library(antaresRead)
library(antaresEditObject)
# Limite ça le EditObject pourrait être limité au CreateStudy
# Bon AntaresRead je vois pas comment faire sans mdr
# Penser à faire comme un requirements.txt genre le truc comme dans logging
# si pas packages alors les installer, et dire dans le README "au pire localement"
# Demander d'ailleurs si on peut virer "antares" du Gitignore
# pour démocratiser AntaresWeb (mais vu que c'est Nicolas qui me l'a filé...)
# Importer des fonctions et variables auxilliaires créées dans d'autres scripts
antaresFunctions_file = file.path("src", "antaresFunctions.R",
fsep = .Platform$file.sep)
source(antaresFunctions_file)
# Est-ce qu'on regroupe aussi les noms de modules dans les paramètres ?
# Est-ce qu'on sépare paramètres, faisant un dossier paramètres ? eh
addNodes_file = file.path("src", "data", "addNodes.R",
fsep = .Platform$file.sep)
source(addNodes_file)
logging_module = file.path("src", "logging.R",
fsep = .Platform$file.sep)
source(logging_module)
setRam(16)
# source("parameters.R")
if (EXPORT_TO_OUTPUT_FOLDER) {
output_dir <- paste0("./output/", generateName("run"))
if (!dir.exists(output_dir)) {
dir.create(output_dir)
}
}
# apparemment le format h5 sert à compresser tout ça ?
# # Convert your study in h5 format
# writeAntaresH5(path = mynewpath)
#
# # Redefine sim path with h5 file
# opts <- setSimulationPath(path = mynewpath)
# prodStack(x = opts)
################################################################################
################################# CREATE STUDY #################################
if (CREATE_STUDY) {
antaresCreateStudy_module = file.path("src", "antaresCreateStudy.R",
fsep = .Platform$file.sep)
source(antaresCreateStudy_module)
}
# Sah quel plaisir for it to run so smoothly now.
# Still gotta implement hydro, however.
# NEXT STEP FOR HYDRO :
# (pendant que j'envoie des sommes de capacité à nicolas chef oui chef)
# implémenter les objets Generator avec _Hyd_ en prenant les facteurs de charge mensuels
# en en faisant des TS horaires
# en faisant * max capacité * units
# et en mettant tout ça dans Run of River
# (not gonna lie, les autres propriétés, je sais pas ce qu'on en fait)
# MDRR C'EST PAS INDIVIDUEL PAR CONTRE c'est juste on va aggregate tous les RoR ensemble
# enfin j'ai l'impression
# à redemander avant à Nicolas
# génial
# et, les objets Battery de type PHS
# bah en vrai y a pas midi à 14h en terme de nombre de propriétés
# ce qui est pas clair dans ma tête à la rigueur c'est diff entre
# injection, soutirage, stock, efficacité
# (et surtout c'est pas redondant ? genre injection = stock * efficacité nn ?)
# AH NON SI OK J'AI je crois
# capacité c'est énorme c'est la maxi taille du réservoir genre 34800
# injection c'est oulah ça peut pas non plus fournir infini MW dans le réseau à un instant t
# et du coup c'est le max power qui ici est à 182
# il faut plutôt faire d'ailleurs un objet par units parce que y a pas de "unités"
# dans antares batteries
################################################################################
############################### LAUNCH SIMULATION ##############################
if (LAUNCH_SIMULATION) {
# Peut-être ici mettre les logs globaux ce qui permettrait de mettre genre
# starting simulation..
# ou skipped simulation... skipped reading results... done !
antaresLaunchSimulation_module = file.path("src", "antaresLaunchSimulation.R",
fsep = .Platform$file.sep)
source(antaresLaunchSimulation_module)
}
################################################################################
################################## READ RESULTS ################################
if (READ_RESULTS) {
antaresReadResults_module = file.path("src", "antaresReadResults.R",
fsep = .Platform$file.sep)
source(antaresReadResults_module)
}
################################################################################
# Commentaires variés
# Ca existe de stocker des objets R qqpart ?
# Ca peut diminuer le temps de fetch renewables.ninja, surtout quand on a peu de points.
# Mais, c'est peut-être plus risqué en un sens, je sais pas.
# Dans input un dossier "Robjects" ou quoi ça pourrait le faire.
# D'après stackoverflow :
#   You can use saveRDS and readRDS functions:
#
#     library(tibble)
#   test <- tibble(a= list(c(1,2), c(3,4)))
#   saveRDS(test, "c:/test.rds")
#   test_2 <- readRDS("c:/test.rds"))
# identical(test, test_2)
# In the readr package there are read_rds and write_rds functions, which even allow compression to be set.
# if (ADD_VOLL) {
#   addVoLL_module = file.path("src", "data", "addVoLL.R")
#   source(addVoLL_module)
#   addVoLLToAntares(nodes, study_path, study_name, log_verbose, console_verbose, fullLog_file, errorsLog_file)
#   message = paste(Sys.time(), "- [MAIN] Done adding VoLL !")
#   log_message(message, fullLog_file, console_verbose)
# }
# La suite : lancer une simulation et la visionner
# Sachant que le visionnage peut être un truc bien à faire dans un second temps
# Ce qu'il faut faire en fait c'est réussir à stocker genre des presets
# (dossiers studies tout prêts dans inputs ?)
# et prévoir de lancer des simulations, de visionner des résultats dans un second temps
# (des presets de simulation en fait aussi)
# (même pour tester des fonctions Viz de toute façon ce sera mieux)
