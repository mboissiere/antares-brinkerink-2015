study_basename <- "Etude_sur_R_Monde"
# Dans l'idéal ce serait bien aussi d'avoir une sorte de generateName intelligent avec les nodes genre
# ou un paramètre mais fin
# si j'ai europe_nodes qu'il écrive europe, si j'ai all nodes qu'il écrive monde, sinon cas par cas etc
GENERATE_LOAD = TRUE
GENERATE_REN = FALSE
GENERATE_WIND = TRUE
GENERATE_SOLAR_PV = TRUE
GENERATE_SOLAR_CSP = FALSE
GENERATE_LINES = TRUE
GENERATE_THERMAL = TRUE
# THERMAL_TYPES = c("Hard Coal", "Gas", "Nuclear", "Mixed Fuel")
THERMAL_TYPES = c("Hard Coal", "Gas", "Nuclear")
ADD_VOLL = TRUE
INCLUDE_ZERO_NTC_LINES = FALSE
PRINT_FULL_LOG_TO_CONSOLE = TRUE
#### Todo: centralize but separate in different categories
# Like : addNodes parameters###
### Logging parameters ####
#etc#
DEFAULT_SCALING_FACTOR = 25
# NODES = c("EU-FRA", "EU-DEU", "EU-CHE")
#source(".\\src\\data\\addNodes.R") mdr le récursif là ouh là lààà
# Hardcoded to avoid recursion even though we can call getAllNodes()
DEANE_NODES_ALL = c('AF-AGO', 'AF-BDI', 'AF-BEN', 'AF-BFA', 'AF-BWA', 'AF-CAF',
'AF-CIV', 'AF-CMR', 'AF-COD', 'AF-COG', 'AF-CPV', 'AF-DJI',
'AF-DZA', 'AF-EGY', 'AF-ERI', 'AF-ESH', 'AF-ETH', 'AF-GAB',
'AF-GHA', 'AF-GIN', 'AF-GMB', 'AF-GNB', 'AF-GNQ', 'AF-KEN',
'AF-LBR', 'AF-LBY', 'AF-LSO', 'AF-MAR', 'AF-MDG', 'AF-MLI',
'AF-MOZ', 'AF-MRT', 'AF-MUS', 'AF-MWI', 'AF-NAM', 'AF-NER',
'AF-NGA', 'AF-RWA', 'AF-SDN', 'AF-SEN', 'AF-SLE', 'AF-SWZ',
'AF-TGO', 'AF-TUN', 'AF-TZA', 'AF-UGA', 'AF-ZAF', 'AF-ZMB',
'AF-ZWE', 'AS-AFG', 'AS-ARE', 'AS-BGD', 'AS-BHR', 'AS-BRN',
'AS-BTN', 'AS-CHN-AN', 'AS-CHN-BE', 'AS-CHN-CH', 'AS-CHN-EM',
'AS-CHN-FU', 'AS-CHN-GA', 'AS-CHN-GD', 'AS-CHN-GU', 'AS-CHN-GX',
'AS-CHN-HA', 'AS-CHN-HB', 'AS-CHN-HE', 'AS-CHN-HJ', 'AS-CHN-HK',
'AS-CHN-HN', 'AS-CHN-HU', 'AS-CHN-JI', 'AS-CHN-JS', 'AS-CHN-JX',
'AS-CHN-LI', 'AS-CHN-MA', 'AS-CHN-NI', 'AS-CHN-QI', 'AS-CHN-SC',
'AS-CHN-SD', 'AS-CHN-SH', 'AS-CHN-SI', 'AS-CHN-SX', 'AS-CHN-TI',
'AS-CHN-TJ', 'AS-CHN-WM', 'AS-CHN-XI', 'AS-CHN-YU', 'AS-CHN-ZH',
'AS-IDN', 'AS-IND-EA', 'AS-IND-NE', 'AS-IND-NO', 'AS-IND-SO',
'AS-IND-WE', 'AS-IRN', 'AS-IRQ', 'AS-ISR', 'AS-JOR', 'AS-JPN-CE',
'AS-JPN-HO', 'AS-JPN-KY', 'AS-JPN-OK', 'AS-JPN-SH', 'AS-JPN-TO',
'AS-KAZ', 'AS-KGZ', 'AS-KHM', 'AS-KOR', 'AS-KWT', 'AS-LAO',
'AS-LBN', 'AS-LKA', 'AS-MMR', 'AS-MNG', 'AS-MYS', 'AS-NPL',
'AS-OMN', 'AS-PAK', 'AS-PHL', 'AS-PRK', 'AS-QAT', 'AS-RUS-CE',
'AS-RUS-FE', 'AS-RUS-MV', 'AS-RUS-NW', 'AS-RUS-SI', 'AS-RUS-SO',
'AS-RUS-UR', 'AS-SAU', 'AS-SGP', 'AS-SYR', 'AS-THA', 'AS-TJK',
'AS-TKM', 'AS-TUR', 'AS-TWN', 'AS-UZB', 'AS-VNM', 'AS-YEM',
'EU-ALB', 'EU-ARM', 'EU-AUT', 'EU-AZE', 'EU-BEL', 'EU-BGR',
'EU-BIH', 'EU-BLR', 'EU-CHE', 'EU-CYP', 'EU-CZE', 'EU-DEU',
'EU-DNK', 'EU-ESP', 'EU-EST', 'EU-FIN', 'EU-FRA', 'EU-GBR',
'EU-GEO', 'EU-GRC', 'EU-HRV', 'EU-HUN', 'EU-IRL', 'EU-ISL',
'EU-ITA', 'EU-KOS', 'EU-LTU', 'EU-LUX', 'EU-LVA', 'EU-MDA',
'EU-MKD', 'EU-MNE', 'EU-NLD', 'EU-NOR', 'EU-POL', 'EU-PRT',
'EU-ROU', 'EU-SRB', 'EU-SVK', 'EU-SVN', 'EU-SWE', 'EU-UKR',
'OC-ATA', 'OC-AUS-NT', 'OC-AUS-QL', 'OC-AUS-SA', 'OC-AUS-SW',
'OC-AUS-TA', 'OC-AUS-VI', 'OC-AUS-WA', 'OC-FJI', 'OC-NZL',
'OC-PNG', 'NA-CAN-AB', 'NA-CAN-AR', 'NA-CAN-BC', 'NA-CAN-MB',
'NA-CAN-NL', 'NA-CAN-NO', 'NA-CAN-ON', 'NA-CAN-QC', 'NA-CAN-SK',
'NA-CRI', 'NA-CUB', 'NA-DOM', 'NA-GTM', 'NA-HND', 'NA-JAM',
'NA-MEX', 'NA-NIC', 'NA-PAN', 'NA-SLV', 'NA-TTO', 'NA-USA-AK',
'NA-USA-AZ', 'NA-USA-CA', 'NA-USA-ER', 'NA-USA-FR', 'NA-USA-GU',
'NA-USA-HA', 'NA-USA-ME', 'NA-USA-MW', 'NA-USA-NE', 'NA-USA-NW',
'NA-USA-NY', 'NA-USA-PR', 'NA-USA-RA', 'NA-USA-RE', 'NA-USA-RM',
'NA-USA-RW', 'NA-USA-SA', 'NA-USA-SC', 'NA-USA-SE', 'NA-USA-SN',
'NA-USA-SS', 'NA-USA-SV', 'NA-USA-SW', 'SA-ARG', 'SA-BOL',
'SA-BRA-CN', 'SA-BRA-CW', 'SA-BRA-J1', 'SA-BRA-J2', 'SA-BRA-J3',
'SA-BRA-NE', 'SA-BRA-NW', 'SA-BRA-SE', 'SA-BRA-SO', 'SA-BRA-WE',
'SA-CHL', 'SA-COL', 'SA-ECU', 'SA-GUF', 'SA-GUY', 'SA-PER',
'SA-PRY', 'SA-URY', 'SA-VEN')
DEANE_NODES_EUROPE = c('EU-ALB', 'EU-ARM', 'EU-AUT', 'EU-AZE', 'EU-BEL', 'EU-BGR',
'EU-BIH', 'EU-BLR', 'EU-CHE', 'EU-CYP', 'EU-CZE', 'EU-DEU',
'EU-DNK', 'EU-ESP', 'EU-EST', 'EU-FIN', 'EU-FRA', 'EU-GBR',
'EU-GEO', 'EU-GRC', 'EU-HRV', 'EU-HUN', 'EU-IRL', 'EU-ISL',
'EU-ITA', 'EU-KOS', 'EU-LTU', 'EU-LUX', 'EU-LVA', 'EU-MDA',
'EU-MKD', 'EU-MNE', 'EU-NLD', 'EU-NOR', 'EU-POL', 'EU-PRT',
'EU-ROU', 'EU-SRB', 'EU-SVK', 'EU-SVN', 'EU-SWE', 'EU-UKR')
# C'est clairement trop brouillon personne va scroll pour changer NODES
# Il faudrait faire genre un "objects" et "variables" fin un truc qui ne change pas
# et un truc de paramètres que l'utilisateur peut être amené à bouger souvent
# (Comme je le dis depuis qq temps oups)
# NODES = DEANE_NODES_EUROPE
NODES = c("EU-CHE", "EU-DEU", "EU-FRA")
# plutôt avoir des variables qui peuvent bcp changer en "nodes"
# et des variables vrmt statiques (comme horizon plus bas, en attendant le preset...)
# en "NODES"
# ce serait bien que preset change aussi le NOM DE L'ETUDE
# c'est tellement ridicule d'avoir écrit "Monde" quand je fais un test sur trois points
# NODES = getNodesFromContinents(c("Europe"))
# NODES = c("EU-MDA", "EU-MKD", "EU-MNE") # test on 3 problematic countries
# NODES = "EU-MDA"
# NODES = c("EU-FRA", "AF-MAR", "AS-JPN-CE", "NA-CAN-QC", "OC-NZL", "SA-CHL")
# NODES = getAllNodes()
# Bientôt le All Nodes, pour ça il faut être sur d'avoir les bons parametres sur tous les secteurs thermiques
# A terme, ce serait tellement bien d'avoir une autorisation d'upload le dossier antares dans GitHub
# (quitte à mettre genre un licensing etc dans le readme)
# puis de faire un .bat qui lance automatiquement AntaresWebWorker en lancant le programme ? jsp
# Pourrait configurer en mode : "all", "continents", "select", etc.
# avec un fichier configureNodes.R par exemple
# dans sa version ultime je verrais bien un Excel avec choix multiples pour le front utilisateur, comme pour TiTAN
# (et si on pousse TiTAN jusqu'au bout, pourquoi pas un .bat ?)
# Ce qui est pas mal avec ça c'est que je peux mettre une version de R dans le Git et
# ça fait du local
#' @echo off
#' set R_PATH="C:\Program Files\R\R-4.0.2\bin\Rscript.exe"
#' set SCRIPT_PATH="%~dp0main.R"
#' %R_PATH% %SCRIPT_PATH%
#'   pause
simulation_mode = "Economy" # "Adequacy", "Economy" ou "Draft"
horizon = 2015 # entier, année d'étude
nb_MCyears = 10 # entier, nombre d'années Monte-Carlo
# A noter que nb_MCyears est probablement une variable qui peut changer
# et, qui affecte temps de la partie LaunchSimulation
# ajouter la partie configuration, qui contient notamment TS management,
# dans le grand excel qui résume les variables Antares
RENEWABLE_GENERATION_MODELLING = "aggregated" # "aggregated" ou "clusters"
# zones = c("AUT", "BEL", "BGR", "HRV", "CYP", "CZE", "DNK", "EST", "FIN", "FRA")
#c("FRA", "GBR", "DEU", "ITA", "ESP")
# pour l'environnement r : faire plutot dossier "study" de sorte à pouvoir en fait faire des presets
# qui pourraient etre activés avec un machin dans parameters, téléchargées, etc
#zones = deane_nodes_df$Node
#print(zones)
#print(zones[1])
#print(getISOfromDeane(zones[1]))
#print(getAntaresCoordsFromCountry(getISOfromDeane(zones[1])))
## Script principal regroupant le coeur du processus ##
## Les objets sont typiquement déjà définis dans les fichiers auxilliaires
# Charger les packages
library(antaresRead)
library(antaresEditObject)
# Limite ça le EditObject pourrait être limité au CreateStudy
# Bon AntaresRead je vois pas comment faire sans mdr
# Penser à faire comme un requirements.txt genre le truc comme dans logging
# si pas packages alors les installer, et dire dans le README "au pire localement"
# Demander d'ailleurs si on peut virer "antares" du Gitignore
# pour démocratiser AntaresWeb (mais vu que c'est Nicolas qui me l'a filé...)
# Importer des fonctions et variables auxilliaires créées dans d'autres scripts
antaresFunctions_file = file.path("src", "antaresFunctions.R",
fsep = .Platform$file.sep)
source(antaresFunctions_file)
# Est-ce qu'on regroupe aussi les noms de modules dans les paramètres ?
# Est-ce qu'on sépare paramètres, faisant un dossier paramètres ? eh
addNodes_file = file.path("src", "data", "addNodes.R",
fsep = .Platform$file.sep)
source(addNodes_file)
logging_module = file.path("src", "logging.R",
fsep = .Platform$file.sep)
source(logging_module)
source("parameters.R")
if (EXPORT_TO_OUTPUT_FOLDER) {
output_dir <- paste0("./output/", generateName("run"))
if (!dir.exists(output_dir)) {
dir.create(output_dir)
}
}
# apparemment le format h5 sert à compresser tout ça ?
# # Convert your study in h5 format
# writeAntaresH5(path = mynewpath)
#
# # Redefine sim path with h5 file
# opts <- setSimulationPath(path = mynewpath)
# prodStack(x = opts)
################################################################################
################################# CREATE STUDY #################################
if (CREATE_STUDY) {
antaresCreateStudy_module = file.path("src", "antaresCreateStudy.R",
fsep = .Platform$file.sep)
source(antaresCreateStudy_module)
}
################################################################################
############################### LAUNCH SIMULATION ##############################
if (LAUNCH_SIMULATION) {
# Peut-être ici mettre les logs globaux ce qui permettrait de mettre genre
# starting simulation..
# ou skipped simulation... skipped reading results... done !
antaresLaunchSimulation_module = file.path("src", "antaresLaunchSimulation.R",
fsep = .Platform$file.sep)
source(antaresLaunchSimulation_module)
}
################################################################################
################################## READ RESULTS ################################
if (READ_RESULTS) {
antaresReadResults_module = file.path("src", "antaresReadResults.R",
fsep = .Platform$file.sep)
source(antaresReadResults_module)
}
################################################################################
# Commentaires variés
# Ca existe de stocker des objets R qqpart ?
# Ca peut diminuer le temps de fetch renewables.ninja, surtout quand on a peu de points.
# Mais, c'est peut-être plus risqué en un sens, je sais pas.
# Dans input un dossier "Robjects" ou quoi ça pourrait le faire.
# D'après stackoverflow :
#   You can use saveRDS and readRDS functions:
#
#     library(tibble)
#   test <- tibble(a= list(c(1,2), c(3,4)))
#   saveRDS(test, "c:/test.rds")
#   test_2 <- readRDS("c:/test.rds"))
# identical(test, test_2)
# In the readr package there are read_rds and write_rds functions, which even allow compression to be set.
# if (ADD_VOLL) {
#   addVoLL_module = file.path("src", "data", "addVoLL.R")
#   source(addVoLL_module)
#   addVoLLToAntares(nodes, study_path, study_name, log_verbose, console_verbose, fullLog_file, errorsLog_file)
#   message = paste(Sys.time(), "- [MAIN] Done adding VoLL !")
#   log_message(message, fullLog_file, console_verbose)
# }
# La suite : lancer une simulation et la visionner
# Sachant que le visionnage peut être un truc bien à faire dans un second temps
# Ce qu'il faut faire en fait c'est réussir à stocker genre des presets
# (dossiers studies tout prêts dans inputs ?)
# et prévoir de lancer des simulations, de visionner des résultats dans un second temps
# (des presets de simulation en fait aussi)
# (même pour tester des fonctions Viz de toute façon ce sera mieux)
print(generators_tbl)
## Script principal regroupant le coeur du processus ##
## Les objets sont typiquement déjà définis dans les fichiers auxilliaires
# Charger les packages
library(antaresRead)
library(antaresEditObject)
# Limite ça le EditObject pourrait être limité au CreateStudy
# Bon AntaresRead je vois pas comment faire sans mdr
# Penser à faire comme un requirements.txt genre le truc comme dans logging
# si pas packages alors les installer, et dire dans le README "au pire localement"
# Demander d'ailleurs si on peut virer "antares" du Gitignore
# pour démocratiser AntaresWeb (mais vu que c'est Nicolas qui me l'a filé...)
# Importer des fonctions et variables auxilliaires créées dans d'autres scripts
antaresFunctions_file = file.path("src", "antaresFunctions.R",
fsep = .Platform$file.sep)
source(antaresFunctions_file)
# Est-ce qu'on regroupe aussi les noms de modules dans les paramètres ?
# Est-ce qu'on sépare paramètres, faisant un dossier paramètres ? eh
addNodes_file = file.path("src", "data", "addNodes.R",
fsep = .Platform$file.sep)
source(addNodes_file)
logging_module = file.path("src", "logging.R",
fsep = .Platform$file.sep)
source(logging_module)
source("parameters.R")
if (EXPORT_TO_OUTPUT_FOLDER) {
output_dir <- paste0("./output/", generateName("run"))
if (!dir.exists(output_dir)) {
dir.create(output_dir)
}
}
# apparemment le format h5 sert à compresser tout ça ?
# # Convert your study in h5 format
# writeAntaresH5(path = mynewpath)
#
# # Redefine sim path with h5 file
# opts <- setSimulationPath(path = mynewpath)
# prodStack(x = opts)
################################################################################
################################# CREATE STUDY #################################
if (CREATE_STUDY) {
antaresCreateStudy_module = file.path("src", "antaresCreateStudy.R",
fsep = .Platform$file.sep)
source(antaresCreateStudy_module)
}
################################################################################
############################### LAUNCH SIMULATION ##############################
if (LAUNCH_SIMULATION) {
# Peut-être ici mettre les logs globaux ce qui permettrait de mettre genre
# starting simulation..
# ou skipped simulation... skipped reading results... done !
antaresLaunchSimulation_module = file.path("src", "antaresLaunchSimulation.R",
fsep = .Platform$file.sep)
source(antaresLaunchSimulation_module)
}
################################################################################
################################## READ RESULTS ################################
if (READ_RESULTS) {
antaresReadResults_module = file.path("src", "antaresReadResults.R",
fsep = .Platform$file.sep)
source(antaresReadResults_module)
}
################################################################################
# Commentaires variés
# Ca existe de stocker des objets R qqpart ?
# Ca peut diminuer le temps de fetch renewables.ninja, surtout quand on a peu de points.
# Mais, c'est peut-être plus risqué en un sens, je sais pas.
# Dans input un dossier "Robjects" ou quoi ça pourrait le faire.
# D'après stackoverflow :
#   You can use saveRDS and readRDS functions:
#
#     library(tibble)
#   test <- tibble(a= list(c(1,2), c(3,4)))
#   saveRDS(test, "c:/test.rds")
#   test_2 <- readRDS("c:/test.rds"))
# identical(test, test_2)
# In the readr package there are read_rds and write_rds functions, which even allow compression to be set.
# if (ADD_VOLL) {
#   addVoLL_module = file.path("src", "data", "addVoLL.R")
#   source(addVoLL_module)
#   addVoLLToAntares(nodes, study_path, study_name, log_verbose, console_verbose, fullLog_file, errorsLog_file)
#   message = paste(Sys.time(), "- [MAIN] Done adding VoLL !")
#   log_message(message, fullLog_file, console_verbose)
# }
# La suite : lancer une simulation et la visionner
# Sachant que le visionnage peut être un truc bien à faire dans un second temps
# Ce qu'il faut faire en fait c'est réussir à stocker genre des presets
# (dossiers studies tout prêts dans inputs ?)
# et prévoir de lancer des simulations, de visionner des résultats dans un second temps
# (des presets de simulation en fait aussi)
# (même pour tester des fonctions Viz de toute façon ce sera mieux)
## Script principal regroupant le coeur du processus ##
## Les objets sont typiquement déjà définis dans les fichiers auxilliaires
# Charger les packages
library(antaresRead)
library(antaresEditObject)
# Limite ça le EditObject pourrait être limité au CreateStudy
# Bon AntaresRead je vois pas comment faire sans mdr
# Penser à faire comme un requirements.txt genre le truc comme dans logging
# si pas packages alors les installer, et dire dans le README "au pire localement"
# Demander d'ailleurs si on peut virer "antares" du Gitignore
# pour démocratiser AntaresWeb (mais vu que c'est Nicolas qui me l'a filé...)
# Importer des fonctions et variables auxilliaires créées dans d'autres scripts
antaresFunctions_file = file.path("src", "antaresFunctions.R",
fsep = .Platform$file.sep)
source(antaresFunctions_file)
# Est-ce qu'on regroupe aussi les noms de modules dans les paramètres ?
# Est-ce qu'on sépare paramètres, faisant un dossier paramètres ? eh
addNodes_file = file.path("src", "data", "addNodes.R",
fsep = .Platform$file.sep)
source(addNodes_file)
logging_module = file.path("src", "logging.R",
fsep = .Platform$file.sep)
source(logging_module)
source("parameters.R")
if (EXPORT_TO_OUTPUT_FOLDER) {
output_dir <- paste0("./output/", generateName("run"))
if (!dir.exists(output_dir)) {
dir.create(output_dir)
}
}
# apparemment le format h5 sert à compresser tout ça ?
# # Convert your study in h5 format
# writeAntaresH5(path = mynewpath)
#
# # Redefine sim path with h5 file
# opts <- setSimulationPath(path = mynewpath)
# prodStack(x = opts)
################################################################################
################################# CREATE STUDY #################################
if (CREATE_STUDY) {
antaresCreateStudy_module = file.path("src", "antaresCreateStudy.R",
fsep = .Platform$file.sep)
source(antaresCreateStudy_module)
}
################################################################################
############################### LAUNCH SIMULATION ##############################
if (LAUNCH_SIMULATION) {
# Peut-être ici mettre les logs globaux ce qui permettrait de mettre genre
# starting simulation..
# ou skipped simulation... skipped reading results... done !
antaresLaunchSimulation_module = file.path("src", "antaresLaunchSimulation.R",
fsep = .Platform$file.sep)
source(antaresLaunchSimulation_module)
}
################################################################################
################################## READ RESULTS ################################
if (READ_RESULTS) {
antaresReadResults_module = file.path("src", "antaresReadResults.R",
fsep = .Platform$file.sep)
source(antaresReadResults_module)
}
################################################################################
# Commentaires variés
# Ca existe de stocker des objets R qqpart ?
# Ca peut diminuer le temps de fetch renewables.ninja, surtout quand on a peu de points.
# Mais, c'est peut-être plus risqué en un sens, je sais pas.
# Dans input un dossier "Robjects" ou quoi ça pourrait le faire.
# D'après stackoverflow :
#   You can use saveRDS and readRDS functions:
#
#     library(tibble)
#   test <- tibble(a= list(c(1,2), c(3,4)))
#   saveRDS(test, "c:/test.rds")
#   test_2 <- readRDS("c:/test.rds"))
# identical(test, test_2)
# In the readr package there are read_rds and write_rds functions, which even allow compression to be set.
# if (ADD_VOLL) {
#   addVoLL_module = file.path("src", "data", "addVoLL.R")
#   source(addVoLL_module)
#   addVoLLToAntares(nodes, study_path, study_name, log_verbose, console_verbose, fullLog_file, errorsLog_file)
#   message = paste(Sys.time(), "- [MAIN] Done adding VoLL !")
#   log_message(message, fullLog_file, console_verbose)
# }
# La suite : lancer une simulation et la visionner
# Sachant que le visionnage peut être un truc bien à faire dans un second temps
# Ce qu'il faut faire en fait c'est réussir à stocker genre des presets
# (dossiers studies tout prêts dans inputs ?)
# et prévoir de lancer des simulations, de visionner des résultats dans un second temps
# (des presets de simulation en fait aussi)
# (même pour tester des fonctions Viz de toute façon ce sera mieux)
## Script principal regroupant le coeur du processus ##
## Les objets sont typiquement déjà définis dans les fichiers auxilliaires
# Charger les packages
library(antaresRead)
library(antaresEditObject)
# Limite ça le EditObject pourrait être limité au CreateStudy
# Bon AntaresRead je vois pas comment faire sans mdr
# Penser à faire comme un requirements.txt genre le truc comme dans logging
# si pas packages alors les installer, et dire dans le README "au pire localement"
# Demander d'ailleurs si on peut virer "antares" du Gitignore
# pour démocratiser AntaresWeb (mais vu que c'est Nicolas qui me l'a filé...)
# Importer des fonctions et variables auxilliaires créées dans d'autres scripts
antaresFunctions_file = file.path("src", "antaresFunctions.R",
fsep = .Platform$file.sep)
source(antaresFunctions_file)
# Est-ce qu'on regroupe aussi les noms de modules dans les paramètres ?
# Est-ce qu'on sépare paramètres, faisant un dossier paramètres ? eh
addNodes_file = file.path("src", "data", "addNodes.R",
fsep = .Platform$file.sep)
source(addNodes_file)
logging_module = file.path("src", "logging.R",
fsep = .Platform$file.sep)
source(logging_module)
setRam(16)
# source("parameters.R")
if (EXPORT_TO_OUTPUT_FOLDER) {
output_dir <- paste0("./output/", generateName("run"))
if (!dir.exists(output_dir)) {
dir.create(output_dir)
}
}
# apparemment le format h5 sert à compresser tout ça ?
# # Convert your study in h5 format
# writeAntaresH5(path = mynewpath)
#
# # Redefine sim path with h5 file
# opts <- setSimulationPath(path = mynewpath)
# prodStack(x = opts)
################################################################################
################################# CREATE STUDY #################################
if (CREATE_STUDY) {
antaresCreateStudy_module = file.path("src", "antaresCreateStudy.R",
fsep = .Platform$file.sep)
source(antaresCreateStudy_module)
}
# Sah quel plaisir for it to run so smoothly now.
# Still gotta implement hydro, however.
# NEXT STEP FOR HYDRO :
# (pendant que j'envoie des sommes de capacité à nicolas chef oui chef)
# implémenter les objets Generator avec _Hyd_ en prenant les facteurs de charge mensuels
# en en faisant des TS horaires
# en faisant * max capacité * units
# et en mettant tout ça dans Run of River
# (not gonna lie, les autres propriétés, je sais pas ce qu'on en fait)
# MDRR C'EST PAS INDIVIDUEL PAR CONTRE c'est juste on va aggregate tous les RoR ensemble
# enfin j'ai l'impression
# à redemander avant à Nicolas
# génial
# et, les objets Battery de type PHS
# bah en vrai y a pas midi à 14h en terme de nombre de propriétés
# ce qui est pas clair dans ma tête à la rigueur c'est diff entre
# injection, soutirage, stock, efficacité
# (et surtout c'est pas redondant ? genre injection = stock * efficacité nn ?)
# AH NON SI OK J'AI je crois
# capacité c'est énorme c'est la maxi taille du réservoir genre 34800
# injection c'est oulah ça peut pas non plus fournir infini MW dans le réseau à un instant t
# et du coup c'est le max power qui ici est à 182
# il faut plutôt faire d'ailleurs un objet par units parce que y a pas de "unités"
# dans antares batteries
################################################################################
############################### LAUNCH SIMULATION ##############################
if (LAUNCH_SIMULATION) {
# Peut-être ici mettre les logs globaux ce qui permettrait de mettre genre
# starting simulation..
# ou skipped simulation... skipped reading results... done !
antaresLaunchSimulation_module = file.path("src", "antaresLaunchSimulation.R",
fsep = .Platform$file.sep)
source(antaresLaunchSimulation_module)
}
################################################################################
################################## READ RESULTS ################################
if (READ_RESULTS) {
antaresReadResults_module = file.path("src", "antaresReadResults.R",
fsep = .Platform$file.sep)
source(antaresReadResults_module)
}
################################################################################
# Commentaires variés
# Ca existe de stocker des objets R qqpart ?
# Ca peut diminuer le temps de fetch renewables.ninja, surtout quand on a peu de points.
# Mais, c'est peut-être plus risqué en un sens, je sais pas.
# Dans input un dossier "Robjects" ou quoi ça pourrait le faire.
# D'après stackoverflow :
#   You can use saveRDS and readRDS functions:
#
#     library(tibble)
#   test <- tibble(a= list(c(1,2), c(3,4)))
#   saveRDS(test, "c:/test.rds")
#   test_2 <- readRDS("c:/test.rds"))
# identical(test, test_2)
# In the readr package there are read_rds and write_rds functions, which even allow compression to be set.
# if (ADD_VOLL) {
#   addVoLL_module = file.path("src", "data", "addVoLL.R")
#   source(addVoLL_module)
#   addVoLLToAntares(nodes, study_path, study_name, log_verbose, console_verbose, fullLog_file, errorsLog_file)
#   message = paste(Sys.time(), "- [MAIN] Done adding VoLL !")
#   log_message(message, fullLog_file, console_verbose)
# }
# La suite : lancer une simulation et la visionner
# Sachant que le visionnage peut être un truc bien à faire dans un second temps
# Ce qu'il faut faire en fait c'est réussir à stocker genre des presets
# (dossiers studies tout prêts dans inputs ?)
# et prévoir de lancer des simulations, de visionner des résultats dans un second temps
# (des presets de simulation en fait aussi)
# (même pour tester des fonctions Viz de toute façon ce sera mieux)
