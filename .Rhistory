return(gen_no_prefix)
}
#
# getGeneratorNameWithoutPrefix <- function(generator_name) {
#   gen_no_prefix <- substring(generator_name, 9)
#   return(gen_no_prefix)
# }
# test <- getGeneratorNameWithoutPrefix("AGO_GAS_CAPACITY SCALER")
# print(test)
# And lets test the character limit in Antares
# This is a 10-character string :
# ABCDEABCDE
# 50 OK
# AAAAABBBBBCCCCCDDDDDEEEEEAAAAABBBBBCCCCCDDDDDEEEEE
# 60 OK
# 80 OK
# 85 OK
# 88 !! # 88 is maximum and 89 bugs
# Define function to truncate string to a maximum length
truncateString <- function(name, max_length = 88) {
if (nchar(name) > max_length) {
return(substring(name, 1, max_length))
}
return(name)
}
# INFO [2024-08-14 14:10:45] [THERMAL] - Adding DEU_BIO_BIOMASSGENERAT10962 generator to EU-DEU node...
# ERROR [2024-08-14 14:10:46] [WARN] - Failed to add DEU_WAS_AHKWNEUNKIRCHE10873_BIOMASSGENERAT10950_HEIZKRAFTWERKK11270_KLRANLAGE11381_WASTEINCINERAT11791 generator to EU-DEU node, skipping...
# # et pourtant !!
aggregateEquivalentGenerators <- function(generators_tbl) {
aggregated_generators_tbl <- generators_tbl %>%
group_by(node, cluster_type, nominal_capacity, min_stable_power, co2_emission, variable_cost, start_cost) %>%
summarize(
total_units = sum(nb_units),
combined_names = paste0(
unique(getPrefix(generator_name))[1],  # Extract and keep the prefix only once
paste(
sapply(generator_name, removePrefix),  # Remove the prefix from each name
collapse = "_"
)
),
.groups = 'drop'
) %>%
mutate(generator_name = truncateString(combined_names, 88),
nb_units = total_units) %>%  # Rename and truncate the combined names
select(generator_name, node, cluster_type, nominal_capacity, nb_units, min_stable_power, co2_emission, variable_cost, start_cost)
# select(-combined_names, -total_units)  # Remove the temporary columns
}
test_thermal_properties <- aggregateEquivalentGenerators(test_thermal_properties)
print(test_thermal_properties, n = 100)
# print(test_thermal_properties$generator_name[87])
saveRDS(test_thermal_properties, ".\\src\\objects\\thermal_aggregated_tbl.rds")
test_thermal_properties <- readRDS(".\\src\\objects\\thermal_aggregated_tbl.rds")
print(test_thermal_properties)
# Error in `mutate()`:
#   i In argument: `min_stable_power = nominal_capacity * min_stable_factor/100`.
# Caused by error in `nominal_capacity * min_stable_factor`:
#   ! argument non numérique pour un opérateur binaire
# Run `rlang::last_trace()` to see where the error occurred.
## Possible que ce soit une histoire de : pas toutes les centrales ont des min stable factor
# et donc sur certaines lignes après le pivot wider il y a du NA
# (Sauf que... non. C'est pas maintenance rate, ni mean time to repair)
# Normalement y en a partout
# full_2015_generators_tbl <- readRDS(".\\src\\objects\\full_2015_generators_tbl.rds")
# # # J'espère que ça a filtré quand même...
# # # full_2015_generators_tbl <- filterFor2015(full_2015_generators_tbl)
# # # Faudrait que je fasse de ce path une variable globale
# thermal_types <- c("Hard Coal", "Gas", "Nuclear")
# thermal_clusters_tbl <- filterClusters(full_2015_generators_tbl, thermal_types)
# thermal_clusters_tbl <- getThermalPropertiesTable(thermal_clusters_tbl)
# print(thermal_clusters_tbl)
# print(thermal_clusters_tbl)
addThermalToAntares <- function(thermal_generators_tbl) {
for (row in 1:nrow(thermal_generators_tbl)) {
generator_name = thermal_generators_tbl$generator_name[row] # NB : vu que j'extrais puis fait l'index,
# mieux vaut extraire arrays une fois au début et puis indicer après non ?
# je crois que c'est négligeable as fuck mais jsp
node = thermal_generators_tbl$node[row]
cluster_type = thermal_generators_tbl$cluster_type[row]
nominal_capacity = thermal_generators_tbl$nominal_capacity[row]
nb_units = thermal_generators_tbl$nb_units[row]
min_stable_power = thermal_generators_tbl$min_stable_power[row]
# J'ai quasiment tout des thermiques, mais ce serait bien que j'implémente les
# Maintenance Rate et Mean Time To Repair, qui sont dans les données Deane également....
co2_emission = thermal_generators_tbl$co2_emission[row]
#test = paste("CO2 emission for", generator_name, "plant:", co2_emission)
#print(test)
list_pollutants = list("co2"= co2_emission) # "nh3"= 0.25, "nox"= 0.45, "pm2_5"= 0.25, "pm5"= 0.25, "pm10"= 0.25, "nmvoc"= 0.25, "so2"= 0.25, "op1"= 0.25, "op2"= 0.25, "op3"= 0.25, "op4"= 0.25, "op5"= NULL)
variable_cost = thermal_generators_tbl$variable_cost[row]
start_cost = thermal_generators_tbl$start_cost[row]
tryCatch({
createCluster(
area = node,
cluster_name = generator_name,
group = cluster_type,
unitcount = as.integer(nb_units),
nominalcapacity = nominal_capacity,
min_stable_power = min_stable_power, # Point d'attention : ça s'écrit avec des tirets dans le .ini
# mais en fait c'est ... euh
list_pollutants = list_pollutants,
#...,
#list_pollutants = NULL,
#time_series = NULL,
marginal_cost = variable_cost,
startup_cost = start_cost,
market_bid_cost = variable_cost,
#prepro_data = NULL,
#prepro_modulation = NULL,
add_prefix = FALSE,
overwrite = TRUE
#opts = antaresRead::simOptions()
)
# Error in source(importThermal_module) :
#   src/data/importThermal.R:140:26: '=' inattendu(e)
# 139:         nominalcapacity = nominal_capacity,
# 140:         min-stable-power =
#   ^
##### ???? what
msg = paste("[THERMAL] - Adding", generator_name, "generator to", node,"node...")
logFull(msg)
# Oh, ce serait bien d'avoir le vrai nom ici, en pas capitalisé..... mais ça impliquerait de...
# remove la capitalisation sur le thermique (ce qui serait logique) et de l'avoir que pour
# les renouvelables qui seront comparés à Ninja
# finalement faire une fonction genre .capitalise qu'on active ou non
# au lieu de l'avoir dans l'implémentation direct........ argh oh well
}, error = function(e) {
msg = paste("[WARN] - Failed to add", generator_name, "generator to", node,"node, skipping...")
logError(msg)
})
}
}
# According to rdrr.io documentation, parameters are in similar format to the .ini
# Will become very important for nuclear especially. Right now, will be ignored.
# Will add min stable power as Deane does though.
# [testThermique]
# group = Hard Coal
# name = testThermique
# enabled = True
# unitcount = 1
# nominalcapacity = 0.0
# gen-ts = use global
# min-stable-power = 0.0
# min-up-time = 1
# min-down-time = 1
# must-run = False
# spinning = 0.0
# volatility.forced = 0.0
# volatility.planned = 0.0
# law.forced = uniform
# law.planned = uniform
# marginal-cost = 0.0
# spread-cost = 0.0
# fixed-cost = 0.0
# startup-cost = 0.0
# market-bid-cost = 0.0
# co2 = 0.0
# nh3 = 0.0
# so2 = 0.0
# nox = 0.0
# pm2_5 = 0.0
# pm5 = 0.0
# pm10 = 0.0
# nmvoc = 0.0
# op1 = 0.0
# op2 = 0.0
# op3 = 0.0
# op4 = 0.0
# op5 = 0.0
## Script principal regroupant le coeur du processus ##
## Les objets sont typiquement déjà définis dans les fichiers auxilliaires
# Charger les packages
library(antaresRead)
library(antaresEditObject)
# Limite ça le EditObject pourrait être limité au CreateStudy
# Bon AntaresRead je vois pas comment faire sans mdr
# Penser à faire comme un requirements.txt genre le truc comme dans logging
# si pas packages alors les installer, et dire dans le README "au pire localement"
# Demander d'ailleurs si on peut virer "antares" du Gitignore
# pour démocratiser AntaresWeb (mais vu que c'est Nicolas qui me l'a filé...)
# Importer des fonctions et variables auxilliaires créées dans d'autres scripts
antaresFunctions_file = file.path("src", "antaresFunctions.R",
fsep = .Platform$file.sep)
source(antaresFunctions_file)
# Est-ce qu'on regroupe aussi les noms de modules dans les paramètres ?
# Est-ce qu'on sépare paramètres, faisant un dossier paramètres ? eh
addNodes_file = file.path("src", "data", "addNodes.R",
fsep = .Platform$file.sep)
source(addNodes_file)
logging_module = file.path("src", "logging.R",
fsep = .Platform$file.sep)
source(logging_module)
setRam(16)
# source("parameters.R")
if (EXPORT_TO_OUTPUT_FOLDER) {
output_dir <- paste0("./output/", generateName("run"))
if (!dir.exists(output_dir)) {
dir.create(output_dir)
}
}
# apparemment le format h5 sert à compresser tout ça ?
# # Convert your study in h5 format
# writeAntaresH5(path = mynewpath)
#
# # Redefine sim path with h5 file
# opts <- setSimulationPath(path = mynewpath)
# prodStack(x = opts)
################################################################################
################################# CREATE STUDY #################################
if (CREATE_STUDY) {
antaresCreateStudy_module = file.path("src", "antaresCreateStudy.R",
fsep = .Platform$file.sep)
source(antaresCreateStudy_module)
}
# Sah quel plaisir for it to run so smoothly now.
# Still gotta implement hydro, however.
# NEXT STEP FOR HYDRO :
# (pendant que j'envoie des sommes de capacité à nicolas chef oui chef)
# implémenter les objets Generator avec _Hyd_ en prenant les facteurs de charge mensuels
# en en faisant des TS horaires
# en faisant * max capacité * units
# et en mettant tout ça dans Run of River
# (not gonna lie, les autres propriétés, je sais pas ce qu'on en fait)
# MDRR C'EST PAS INDIVIDUEL PAR CONTRE c'est juste on va aggregate tous les RoR ensemble
# enfin j'ai l'impression
# à redemander avant à Nicolas
# génial
# et, les objets Battery de type PHS
# bah en vrai y a pas midi à 14h en terme de nombre de propriétés
# ce qui est pas clair dans ma tête à la rigueur c'est diff entre
# injection, soutirage, stock, efficacité
# (et surtout c'est pas redondant ? genre injection = stock * efficacité nn ?)
# AH NON SI OK J'AI je crois
# capacité c'est énorme c'est la maxi taille du réservoir genre 34800
# injection c'est oulah ça peut pas non plus fournir infini MW dans le réseau à un instant t
# et du coup c'est le max power qui ici est à 182
# il faut plutôt faire d'ailleurs un objet par units parce que y a pas de "unités"
# dans antares batteries
################################################################################
############################### LAUNCH SIMULATION ##############################
if (LAUNCH_SIMULATION) {
# Peut-être ici mettre les logs globaux ce qui permettrait de mettre genre
# starting simulation..
# ou skipped simulation... skipped reading results... done !
antaresLaunchSimulation_module = file.path("src", "antaresLaunchSimulation.R",
fsep = .Platform$file.sep)
source(antaresLaunchSimulation_module)
}
################################################################################
################################## READ RESULTS ################################
if (READ_RESULTS) {
antaresReadResults_module = file.path("src", "antaresReadResults.R",
fsep = .Platform$file.sep)
source(antaresReadResults_module)
}
################################################################################
# Commentaires variés
# Ca existe de stocker des objets R qqpart ?
# Ca peut diminuer le temps de fetch renewables.ninja, surtout quand on a peu de points.
# Mais, c'est peut-être plus risqué en un sens, je sais pas.
# Dans input un dossier "Robjects" ou quoi ça pourrait le faire.
# D'après stackoverflow :
#   You can use saveRDS and readRDS functions:
#
#     library(tibble)
#   test <- tibble(a= list(c(1,2), c(3,4)))
#   saveRDS(test, "c:/test.rds")
#   test_2 <- readRDS("c:/test.rds"))
# identical(test, test_2)
# In the readr package there are read_rds and write_rds functions, which even allow compression to be set.
# if (ADD_VOLL) {
#   addVoLL_module = file.path("src", "data", "addVoLL.R")
#   source(addVoLL_module)
#   addVoLLToAntares(nodes, study_path, study_name, log_verbose, console_verbose, fullLog_file, errorsLog_file)
#   message = paste(Sys.time(), "- [MAIN] Done adding VoLL !")
#   log_message(message, fullLog_file, console_verbose)
# }
# La suite : lancer une simulation et la visionner
# Sachant que le visionnage peut être un truc bien à faire dans un second temps
# Ce qu'il faut faire en fait c'est réussir à stocker genre des presets
# (dossiers studies tout prêts dans inputs ?)
# et prévoir de lancer des simulations, de visionner des résultats dans un second temps
# (des presets de simulation en fait aussi)
# (même pour tester des fonctions Viz de toute façon ce sera mieux)
## Script principal regroupant le coeur du processus ##
## Les objets sont typiquement déjà définis dans les fichiers auxilliaires
# Charger les packages
library(antaresRead)
library(antaresEditObject)
# Limite ça le EditObject pourrait être limité au CreateStudy
# Bon AntaresRead je vois pas comment faire sans mdr
# Penser à faire comme un requirements.txt genre le truc comme dans logging
# si pas packages alors les installer, et dire dans le README "au pire localement"
# Demander d'ailleurs si on peut virer "antares" du Gitignore
# pour démocratiser AntaresWeb (mais vu que c'est Nicolas qui me l'a filé...)
# Importer des fonctions et variables auxilliaires créées dans d'autres scripts
antaresFunctions_file = file.path("src", "antaresFunctions.R",
fsep = .Platform$file.sep)
source(antaresFunctions_file)
# Est-ce qu'on regroupe aussi les noms de modules dans les paramètres ?
# Est-ce qu'on sépare paramètres, faisant un dossier paramètres ? eh
addNodes_file = file.path("src", "data", "addNodes.R",
fsep = .Platform$file.sep)
source(addNodes_file)
logging_module = file.path("src", "logging.R",
fsep = .Platform$file.sep)
source(logging_module)
setRam(16)
# source("parameters.R")
if (EXPORT_TO_OUTPUT_FOLDER) {
output_dir <- paste0("./output/", generateName("run"))
if (!dir.exists(output_dir)) {
dir.create(output_dir)
}
}
# apparemment le format h5 sert à compresser tout ça ?
# # Convert your study in h5 format
# writeAntaresH5(path = mynewpath)
#
# # Redefine sim path with h5 file
# opts <- setSimulationPath(path = mynewpath)
# prodStack(x = opts)
################################################################################
################################# CREATE STUDY #################################
if (CREATE_STUDY) {
antaresCreateStudy_module = file.path("src", "antaresCreateStudy.R",
fsep = .Platform$file.sep)
source(antaresCreateStudy_module)
}
# Sah quel plaisir for it to run so smoothly now.
# Still gotta implement hydro, however.
# NEXT STEP FOR HYDRO :
# (pendant que j'envoie des sommes de capacité à nicolas chef oui chef)
# implémenter les objets Generator avec _Hyd_ en prenant les facteurs de charge mensuels
# en en faisant des TS horaires
# en faisant * max capacité * units
# et en mettant tout ça dans Run of River
# (not gonna lie, les autres propriétés, je sais pas ce qu'on en fait)
# MDRR C'EST PAS INDIVIDUEL PAR CONTRE c'est juste on va aggregate tous les RoR ensemble
# enfin j'ai l'impression
# à redemander avant à Nicolas
# génial
# et, les objets Battery de type PHS
# bah en vrai y a pas midi à 14h en terme de nombre de propriétés
# ce qui est pas clair dans ma tête à la rigueur c'est diff entre
# injection, soutirage, stock, efficacité
# (et surtout c'est pas redondant ? genre injection = stock * efficacité nn ?)
# AH NON SI OK J'AI je crois
# capacité c'est énorme c'est la maxi taille du réservoir genre 34800
# injection c'est oulah ça peut pas non plus fournir infini MW dans le réseau à un instant t
# et du coup c'est le max power qui ici est à 182
# il faut plutôt faire d'ailleurs un objet par units parce que y a pas de "unités"
# dans antares batteries
################################################################################
############################### LAUNCH SIMULATION ##############################
if (LAUNCH_SIMULATION) {
# Peut-être ici mettre les logs globaux ce qui permettrait de mettre genre
# starting simulation..
# ou skipped simulation... skipped reading results... done !
antaresLaunchSimulation_module = file.path("src", "antaresLaunchSimulation.R",
fsep = .Platform$file.sep)
source(antaresLaunchSimulation_module)
}
################################################################################
################################## READ RESULTS ################################
if (READ_RESULTS) {
antaresReadResults_module = file.path("src", "antaresReadResults.R",
fsep = .Platform$file.sep)
source(antaresReadResults_module)
}
################################################################################
# Commentaires variés
# Ca existe de stocker des objets R qqpart ?
# Ca peut diminuer le temps de fetch renewables.ninja, surtout quand on a peu de points.
# Mais, c'est peut-être plus risqué en un sens, je sais pas.
# Dans input un dossier "Robjects" ou quoi ça pourrait le faire.
# D'après stackoverflow :
#   You can use saveRDS and readRDS functions:
#
#     library(tibble)
#   test <- tibble(a= list(c(1,2), c(3,4)))
#   saveRDS(test, "c:/test.rds")
#   test_2 <- readRDS("c:/test.rds"))
# identical(test, test_2)
# In the readr package there are read_rds and write_rds functions, which even allow compression to be set.
# if (ADD_VOLL) {
#   addVoLL_module = file.path("src", "data", "addVoLL.R")
#   source(addVoLL_module)
#   addVoLLToAntares(nodes, study_path, study_name, log_verbose, console_verbose, fullLog_file, errorsLog_file)
#   message = paste(Sys.time(), "- [MAIN] Done adding VoLL !")
#   log_message(message, fullLog_file, console_verbose)
# }
# La suite : lancer une simulation et la visionner
# Sachant que le visionnage peut être un truc bien à faire dans un second temps
# Ce qu'il faut faire en fait c'est réussir à stocker genre des presets
# (dossiers studies tout prêts dans inputs ?)
# et prévoir de lancer des simulations, de visionner des résultats dans un second temps
# (des presets de simulation en fait aussi)
# (même pour tester des fonctions Viz de toute façon ce sera mieux)
## Script principal regroupant le coeur du processus ##
## Les objets sont typiquement déjà définis dans les fichiers auxilliaires
# Charger les packages
library(antaresRead)
library(antaresEditObject)
# Limite ça le EditObject pourrait être limité au CreateStudy
# Bon AntaresRead je vois pas comment faire sans mdr
# Penser à faire comme un requirements.txt genre le truc comme dans logging
# si pas packages alors les installer, et dire dans le README "au pire localement"
# Demander d'ailleurs si on peut virer "antares" du Gitignore
# pour démocratiser AntaresWeb (mais vu que c'est Nicolas qui me l'a filé...)
# Importer des fonctions et variables auxilliaires créées dans d'autres scripts
antaresFunctions_file = file.path("src", "antaresFunctions.R",
fsep = .Platform$file.sep)
source(antaresFunctions_file)
# Est-ce qu'on regroupe aussi les noms de modules dans les paramètres ?
# Est-ce qu'on sépare paramètres, faisant un dossier paramètres ? eh
addNodes_file = file.path("src", "data", "addNodes.R",
fsep = .Platform$file.sep)
source(addNodes_file)
logging_module = file.path("src", "logging.R",
fsep = .Platform$file.sep)
source(logging_module)
setRam(16)
# source("parameters.R")
if (EXPORT_TO_OUTPUT_FOLDER) {
output_dir <- paste0("./output/", generateName("run"))
if (!dir.exists(output_dir)) {
dir.create(output_dir)
}
}
# apparemment le format h5 sert à compresser tout ça ?
# # Convert your study in h5 format
# writeAntaresH5(path = mynewpath)
#
# # Redefine sim path with h5 file
# opts <- setSimulationPath(path = mynewpath)
# prodStack(x = opts)
################################################################################
################################# CREATE STUDY #################################
if (CREATE_STUDY) {
antaresCreateStudy_module = file.path("src", "antaresCreateStudy.R",
fsep = .Platform$file.sep)
source(antaresCreateStudy_module)
}
# Sah quel plaisir for it to run so smoothly now.
# Still gotta implement hydro, however.
# NEXT STEP FOR HYDRO :
# (pendant que j'envoie des sommes de capacité à nicolas chef oui chef)
# implémenter les objets Generator avec _Hyd_ en prenant les facteurs de charge mensuels
# en en faisant des TS horaires
# en faisant * max capacité * units
# et en mettant tout ça dans Run of River
# (not gonna lie, les autres propriétés, je sais pas ce qu'on en fait)
# MDRR C'EST PAS INDIVIDUEL PAR CONTRE c'est juste on va aggregate tous les RoR ensemble
# enfin j'ai l'impression
# à redemander avant à Nicolas
# génial
# et, les objets Battery de type PHS
# bah en vrai y a pas midi à 14h en terme de nombre de propriétés
# ce qui est pas clair dans ma tête à la rigueur c'est diff entre
# injection, soutirage, stock, efficacité
# (et surtout c'est pas redondant ? genre injection = stock * efficacité nn ?)
# AH NON SI OK J'AI je crois
# capacité c'est énorme c'est la maxi taille du réservoir genre 34800
# injection c'est oulah ça peut pas non plus fournir infini MW dans le réseau à un instant t
# et du coup c'est le max power qui ici est à 182
# il faut plutôt faire d'ailleurs un objet par units parce que y a pas de "unités"
# dans antares batteries
################################################################################
############################### LAUNCH SIMULATION ##############################
if (LAUNCH_SIMULATION) {
# Peut-être ici mettre les logs globaux ce qui permettrait de mettre genre
# starting simulation..
# ou skipped simulation... skipped reading results... done !
antaresLaunchSimulation_module = file.path("src", "antaresLaunchSimulation.R",
fsep = .Platform$file.sep)
source(antaresLaunchSimulation_module)
}
################################################################################
################################## READ RESULTS ################################
if (READ_RESULTS) {
antaresReadResults_module = file.path("src", "antaresReadResults.R",
fsep = .Platform$file.sep)
source(antaresReadResults_module)
}
################################################################################
# Commentaires variés
# Ca existe de stocker des objets R qqpart ?
# Ca peut diminuer le temps de fetch renewables.ninja, surtout quand on a peu de points.
# Mais, c'est peut-être plus risqué en un sens, je sais pas.
# Dans input un dossier "Robjects" ou quoi ça pourrait le faire.
# D'après stackoverflow :
#   You can use saveRDS and readRDS functions:
#
#     library(tibble)
#   test <- tibble(a= list(c(1,2), c(3,4)))
#   saveRDS(test, "c:/test.rds")
#   test_2 <- readRDS("c:/test.rds"))
# identical(test, test_2)
# In the readr package there are read_rds and write_rds functions, which even allow compression to be set.
# if (ADD_VOLL) {
#   addVoLL_module = file.path("src", "data", "addVoLL.R")
#   source(addVoLL_module)
#   addVoLLToAntares(nodes, study_path, study_name, log_verbose, console_verbose, fullLog_file, errorsLog_file)
#   message = paste(Sys.time(), "- [MAIN] Done adding VoLL !")
#   log_message(message, fullLog_file, console_verbose)
# }
# La suite : lancer une simulation et la visionner
# Sachant que le visionnage peut être un truc bien à faire dans un second temps
# Ce qu'il faut faire en fait c'est réussir à stocker genre des presets
# (dossiers studies tout prêts dans inputs ?)
# et prévoir de lancer des simulations, de visionner des résultats dans un second temps
# (des presets de simulation en fait aussi)
# (même pour tester des fonctions Viz de toute façon ce sera mieux)
